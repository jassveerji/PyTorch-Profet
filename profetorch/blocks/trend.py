# AUTOGENERATED! DO NOT EDIT! File to edit: Trend.ipynb (unless otherwise specified).

__all__ = ['Trend']

# Cell
import numpy as np
import matplotlib.pyplot as plt

import torch
import torch.nn as nn
import torch.nn.functional as F

torch.Tensor.ndim = property(lambda x: x.dim())

# Cell
class Trend(nn.Module):
    """
    Broken Trend model, with breakpoints as defined by user.
    parameters:
    - breakpoints (optional): number of breaks in trend
    - date_range: Required if breakpoints is given. Start and stop date in days.
    - mean: mean of time
    - scale: standard deviation of time
    """
    def __init__(self, breakpoints:int=None, date_range=None, mean=0, scale=1):
        super().__init__()
        self.init_layer = nn.Linear(1,1) # first linear bit

        if breakpoints is not None:
            if isinstance(breakpoints, int):
                if breakpoints > 0:
                    breakpoints = np.linspace(*date_range, breakpoints+1, endpoint=False)[1:]
                else:
                    breakpoints = None
            # create deltas which is how the gradient will change
            deltas = torch.zeros(len(breakpoints)) # initialisation
            self.deltas = nn.Parameter(deltas) # make it a parameter

            self.bpoints = (breakpoints -  mean) / scale
        else:
            self.bpoints = None

    def __copy2array(self):
        """
        Saves parameters into wb
        """
        # extract gradient and bias
        w = self.init_layer.weight
        b = self.init_layer.bias
        self.params = [[w,b]] # save it to buffer
        if self.bpoints is not None:
            for d, x1 in zip(self.deltas, self.bpoints):
                y1 = w *x1 + b # find the endpoint of line segment (x1, y1)
                w = w + d # add on the delta to gradient
                b = y1 - w * x1 # find new bias of line segment
                self.params.append([w,b]) # add to buffer

        # create buffer
        self.wb = torch.zeros(len(self.params), len(self.params[0]))
        for i in range(self.wb.shape[0]):
            for j in range(self.wb.shape[1]):
                self.wb[i,j] = self.params[i][j]

    def forward(self, t:torch.Tensor):
        if self.bpoints is not None:
            self.__copy2array() # copy across parameters into matrix
            # get the line segment area (x_sec) for each x
            x_sec = t >= self.bpoints
            x_sec = x_sec.sum(1)

            # get final prediction y = mx +b for relevant section
            return t*self.wb[x_sec][:,:1] + self.wb[x_sec][:,1:]

        else:
            return self.init_layer(t)